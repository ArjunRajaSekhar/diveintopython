
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>7.12.&nbsp;Gestire il cambiamento di requisiti</title>
<link rel="stylesheet" href="/css/diveintopython.css" type="text/css" />
<link rev="made" href="josh@servercobra.com" />
<meta name="generator" content="DocBook XSL Stylesheets V1.52.2" />
<meta name="keywords" content="Python, Dive Into Python, tutorial, object-oriented, programming, documentation, book, free" />
<meta name="description" content="Python from novice to pro" />
<link rel="home" href="http://it.diveintopython.net/" title="Dive Into Python" />
<link rel="up" href="http://it.diveintopython.net/unit_testing/index.html" title="Capitolo&nbsp;7.&nbsp;Test delle unit&agrave; di codice" />
<link rel="previous" href="http://it.diveintopython.net/unit_testing/handling_bugs.html" title="7.11.&nbsp;Come gestire gli errori di programmazione" />
<link rel="next" href="http://it.diveintopython.net/unit_testing/refactoring.html" title="7.13.&nbsp;Rifattorizzazione" />
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-9740779-18']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script></head>
<body>
<style type="text/css">body{margin-top:0!important;padding-top:0!important;min-width:800px!important;}#wm-ipp a:hover{text-decoration:underline!important;}</style>
<table id="Header" width="100%" border="0" cellpadding="0" cellspacing="0" summary="">
<tr>
<td id="breadcrumb" colspan="5" align="left" valign="top">You are here: <a href="http://it.diveintopython.net/index.html">Partenza</a>&nbsp;&gt;&nbsp;<a href="http://it.diveintopython.net/toc/index.html">Dive Into Python</a>&nbsp;&gt;&nbsp;<a href="http://it.diveintopython.net/unit_testing/index.html">Test delle unit&agrave; di codice</a>&nbsp;&gt;&nbsp;<span class="thispage">Gestire il cambiamento di requisiti</span></td>
<td id="navigation" align="right" valign="top">&nbsp;&nbsp;&nbsp;<a href="http://it.diveintopython.net/unit_testing/handling_bugs.html" title="Indietro: “Come gestire gli errori di programmazione”">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;<a href="http://it.diveintopython.net/unit_testing/refactoring.html" title="Avanti: “Rifattorizzazione”">&gt;&gt;</a></td>
</tr>
<tr>
<td colspan="3" id="logocontainer">
<h1 id="logo"><a href="http://it.diveintopython.net/index.html" accesskey="1">Dive Into Python</a></h1>
<p id="tagline">Python per programmatori esperti</p>
</td>
<td colspan="3" align="right">
<form id="search" method="GET" action="http://www.google.com/custom">
<p><label for="q" accesskey="4">Find:&nbsp;</label><input type="text" id="q" name="q" size="20" maxlength="255" value=" " /> <input type="submit" value="Search" /><input type="hidden" name="cof" value="LW:752;L:http://diveintopython.org/images/diveintopython.png;LH:42;AH:left;GL:0;AWFID:3ced2bb1f7f1b212;" /><input type="hidden" name="domains" value="diveintopython.org" /><input type="hidden" name="sitesearch" value="diveintopython.org" /></p>
</form>
</td>
</tr>
</table>
<div class="section" lang="it">
<div class="titlepage">
<div>
<div>
<h2 class="title"><a name="roman.change"></a>7.12.&nbsp;Gestire il cambiamento di requisiti
                  </h2>
</div>
</div>
<div></div>
</div>
<div class="abstract">
<p>
               	A dispetto dei vostri migliori sforzi di bloccare i vostri
               	clienti in un angolo per tirargli fuori gli esatti
               	requisiti del software da sviluppare, sotto la minaccia di
               	sottoporli ad orribili operazioni con forbici e cera
               	bollente, i requisiti cambieranno lo stesso. Molti clienti
               	non sanno cosa vogliono fino a quando non lo vedono, ed
               	anche allora, non sono cos&igrave; bravi a dettagliare esattamente
               	il progetto, a tal punto da fornire indicazioni che possano risultare
               	utili. Ed anche nel caso lo siano, chiederanno sicuramente
               	di pi&ugrave; per la prossima versione del software. Siate quindi
               	preparati ad aggiornare i vostri test quando i requisiti
               	cambieranno.
               
            </p>
</div>
<p>
            	Supponiamo per esempio di voler espandere l'intervallo
            	delle nostre funzioni di conversione dei numeri romani.
            	Ricordate <a href="http://it.diveintopython.net/unit_testing/index.html#roman.divein" title="7.1.&nbsp;Immergersi">la regola</a>
            	che diceva che nessun carattere dovrebbe essere ripetuto
            	pi&ugrave; di tre volte? Bene, i Romani erano disposti a fare
            	un'eccezione a questa regola, rappresentando
            	<tt class="literal">4000</tt> con quattro caratteri
            	<tt class="literal">M</tt> di seguito. Se facciamo questo
            	cambiamento, saremo capaci di espandere il nostro
            	intervallo di numeri convertibili da
            	<tt class="literal">1..3999</tt> a <tt class="literal">1..4999</tt>.
            	Ma prima, abbiamo bisogno di fare qualche cambiamento al
            	codice dei nostri test.
            
         </p>
<div class="example"><a name="d0e24364"></a><h3 class="title">Esempio&nbsp;7.27.&nbsp;Modificare i test per tener conto di nuovi requisiti (<tt class="filename">romantest71.py</tt>)
            </h3>
<p>Se non lo avete ancora fatto, potete
               <a href="http://it.diveintopython.net/download/diveintopython-examples-2.0.zip" title="Download example scripts">
                  scaricare</a> questo ed altri esempi usati in questo libro.
            </p><pre class="programlisting"><span class="pykeyword">
import</span> roman71
<span class="pykeyword">import</span> unittest

<span class="pykeyword">class</span><span class="pyclass"> KnownValues</span>(unittest.TestCase):
    knownValues = ( (1, <span class="pystring">'I'</span>),
                    (2, <span class="pystring">'II'</span>),
                    (3, <span class="pystring">'III'</span>),
                    (4, <span class="pystring">'IV'</span>),
                    (5, <span class="pystring">'V'</span>),
                    (6, <span class="pystring">'VI'</span>),
                    (7, <span class="pystring">'VII'</span>),
                    (8, <span class="pystring">'VIII'</span>),
                    (9, <span class="pystring">'IX'</span>),
                    (10, <span class="pystring">'X'</span>),
                    (50, <span class="pystring">'L'</span>),
                    (100, <span class="pystring">'C'</span>),
                    (500, <span class="pystring">'D'</span>),
                    (1000, <span class="pystring">'M'</span>),
                    (31, <span class="pystring">'XXXI'</span>),
                    (148, <span class="pystring">'CXLVIII'</span>),
                    (294, <span class="pystring">'CCXCIV'</span>),
                    (312, <span class="pystring">'CCCXII'</span>),
                    (421, <span class="pystring">'CDXXI'</span>),
                    (528, <span class="pystring">'DXXVIII'</span>),
                    (621, <span class="pystring">'DCXXI'</span>),
                    (782, <span class="pystring">'DCCLXXXII'</span>),
                    (870, <span class="pystring">'DCCCLXX'</span>),
                    (941, <span class="pystring">'CMXLI'</span>),
                    (1043, <span class="pystring">'MXLIII'</span>),
                    (1110, <span class="pystring">'MCX'</span>),
                    (1226, <span class="pystring">'MCCXXVI'</span>),
                    (1301, <span class="pystring">'MCCCI'</span>),
                    (1485, <span class="pystring">'MCDLXXXV'</span>),
                    (1509, <span class="pystring">'MDIX'</span>),
                    (1607, <span class="pystring">'MDCVII'</span>),
                    (1754, <span class="pystring">'MDCCLIV'</span>),
                    (1832, <span class="pystring">'MDCCCXXXII'</span>),
                    (1993, <span class="pystring">'MCMXCIII'</span>),
                    (2074, <span class="pystring">'MMLXXIV'</span>),
                    (2152, <span class="pystring">'MMCLII'</span>),
                    (2212, <span class="pystring">'MMCCXII'</span>),
                    (2343, <span class="pystring">'MMCCCXLIII'</span>),
                    (2499, <span class="pystring">'MMCDXCIX'</span>),
                    (2574, <span class="pystring">'MMDLXXIV'</span>),
                    (2646, <span class="pystring">'MMDCXLVI'</span>),
                    (2723, <span class="pystring">'MMDCCXXIII'</span>),
                    (2892, <span class="pystring">'MMDCCCXCII'</span>),
                    (2975, <span class="pystring">'MMCMLXXV'</span>),
                    (3051, <span class="pystring">'MMMLI'</span>),
                    (3185, <span class="pystring">'MMMCLXXXV'</span>),
                    (3250, <span class="pystring">'MMMCCL'</span>),
                    (3313, <span class="pystring">'MMMCCCXIII'</span>),
                    (3408, <span class="pystring">'MMMCDVIII'</span>),
                    (3501, <span class="pystring">'MMMDI'</span>),
                    (3610, <span class="pystring">'MMMDCX'</span>),
                    (3743, <span class="pystring">'MMMDCCXLIII'</span>),
                    (3844, <span class="pystring">'MMMDCCCXLIV'</span>),
                    (3888, <span class="pystring">'MMMDCCCLXXXVIII'</span>),
                    (3940, <span class="pystring">'MMMCMXL'</span>),
                    (3999, <span class="pystring">'MMMCMXCIX'</span>),
                    (4000, <span class="pystring">'MMMM'</span>),                                       <a name="roman.change.1.1"></a><img src="http://it.diveintopython.net/images/callouts/1.png" alt="1" border="0" width="12" height="12" />
                    (4500, <span class="pystring">'MMMMD'</span>),
                    (4888, <span class="pystring">'MMMMDCCCLXXXVIII'</span>),
                    (4999, <span class="pystring">'MMMMCMXCIX'</span>))

    <span class="pykeyword">def</span><span class="pyclass"> testToRomanKnownValues</span>(self):
        <span class="pystring">"""toRoman should give known result with known input"""</span>
        <span class="pykeyword">for</span> integer, numeral <span class="pykeyword">in</span> self.knownValues:
            result = roman71.toRoman(integer)
            self.assertEqual(numeral, result)

    <span class="pykeyword">def</span><span class="pyclass"> testFromRomanKnownValues</span>(self):
        <span class="pystring">"""fromRoman should give known result with known input"""</span>
        <span class="pykeyword">for</span> integer, numeral <span class="pykeyword">in</span> self.knownValues:
            result = roman71.fromRoman(numeral)
            self.assertEqual(integer, result)

<span class="pykeyword">class</span><span class="pyclass"> ToRomanBadInput</span>(unittest.TestCase):
    <span class="pykeyword">def</span><span class="pyclass"> testTooLarge</span>(self):
        <span class="pystring">"""toRoman should fail with large input"""</span>
        self.assertRaises(roman71.OutOfRangeError, roman71.toRoman, 5000) <a name="roman.change.1.2"></a><img src="http://it.diveintopython.net/images/callouts/2.png" alt="2" border="0" width="12" height="12" />

    <span class="pykeyword">def</span><span class="pyclass"> testZero</span>(self):
        <span class="pystring">"""toRoman should fail with 0 input"""</span>
        self.assertRaises(roman71.OutOfRangeError, roman71.toRoman, 0)

    <span class="pykeyword">def</span><span class="pyclass"> testNegative</span>(self):
        <span class="pystring">"""toRoman should fail with negative input"""</span>
        self.assertRaises(roman71.OutOfRangeError, roman71.toRoman, -1)

    <span class="pykeyword">def</span><span class="pyclass"> testDecimal</span>(self):
        <span class="pystring">"""toRoman should fail with non-integer input"""</span>
        self.assertRaises(roman71.NotIntegerError, roman71.toRoman, 0.5)

<span class="pykeyword">class</span><span class="pyclass"> FromRomanBadInput</span>(unittest.TestCase):
    <span class="pykeyword">def</span><span class="pyclass"> testTooManyRepeatedNumerals</span>(self):
        <span class="pystring">"""fromRoman should fail with too many repeated numerals"""</span>
        <span class="pykeyword">for</span> s <span class="pykeyword">in</span> (<span class="pystring">'MMMMM'</span>, <span class="pystring">'DD'</span>, <span class="pystring">'CCCC'</span>, <span class="pystring">'LL'</span>, <span class="pystring">'XXXX'</span>, <span class="pystring">'VV'</span>, <span class="pystring">'IIII'</span>):     <a name="roman.change.1.3"></a><img src="http://it.diveintopython.net/images/callouts/3.png" alt="3" border="0" width="12" height="12" />
            self.assertRaises(roman71.InvalidRomanNumeralError, roman71.fromRoman, s)

    <span class="pykeyword">def</span><span class="pyclass"> testRepeatedPairs</span>(self):
        <span class="pystring">"""fromRoman should fail with repeated pairs of numerals"""</span>
        <span class="pykeyword">for</span> s <span class="pykeyword">in</span> (<span class="pystring">'CMCM'</span>, <span class="pystring">'CDCD'</span>, <span class="pystring">'XCXC'</span>, <span class="pystring">'XLXL'</span>, <span class="pystring">'IXIX'</span>, <span class="pystring">'IVIV'</span>):
            self.assertRaises(roman71.InvalidRomanNumeralError, roman71.fromRoman, s)

    <span class="pykeyword">def</span><span class="pyclass"> testMalformedAntecedent</span>(self):
        <span class="pystring">"""fromRoman should fail with malformed antecedents"""</span>
        <span class="pykeyword">for</span> s <span class="pykeyword">in</span> (<span class="pystring">'IIMXCC'</span>, <span class="pystring">'VX'</span>, <span class="pystring">'DCM'</span>, <span class="pystring">'CMM'</span>, <span class="pystring">'IXIV'</span>,
                  <span class="pystring">'MCMC'</span>, <span class="pystring">'XCX'</span>, <span class="pystring">'IVI'</span>, <span class="pystring">'LM'</span>, <span class="pystring">'LD'</span>, <span class="pystring">'LC'</span>):
            self.assertRaises(roman71.InvalidRomanNumeralError, roman71.fromRoman, s)

    <span class="pykeyword">def</span><span class="pyclass"> testBlank</span>(self):
        <span class="pystring">"""fromRoman should fail with blank string"""</span>
        self.assertRaises(roman71.InvalidRomanNumeralError, roman71.fromRoman, <span class="pystring">""</span>)

<span class="pykeyword">class</span><span class="pyclass"> SanityCheck</span>(unittest.TestCase):
    <span class="pykeyword">def</span><span class="pyclass"> testSanity</span>(self):
        <span class="pystring">"""fromRoman(toRoman(n))==n for all n"""</span>
        <span class="pykeyword">for</span> integer <span class="pykeyword">in</span> range(1, 5000):                                    <a name="roman.change.1.4"></a><img src="http://it.diveintopython.net/images/callouts/4.png" alt="4" border="0" width="12" height="12" />
            numeral = roman71.toRoman(integer)
            result = roman71.fromRoman(numeral)
            self.assertEqual(integer, result)

<span class="pykeyword">class</span><span class="pyclass"> CaseCheck</span>(unittest.TestCase):
    <span class="pykeyword">def</span><span class="pyclass"> testToRomanCase</span>(self):
        <span class="pystring">"""toRoman should always return uppercase"""</span>
        <span class="pykeyword">for</span> integer <span class="pykeyword">in</span> range(1, 5000):
            numeral = roman71.toRoman(integer)
            self.assertEqual(numeral, numeral.upper())

    <span class="pykeyword">def</span><span class="pyclass"> testFromRomanCase</span>(self):
        <span class="pystring">"""fromRoman should only accept uppercase input"""</span>
        <span class="pykeyword">for</span> integer <span class="pykeyword">in</span> range(1, 5000):
            numeral = roman71.toRoman(integer)
            roman71.fromRoman(numeral.upper())
            self.assertRaises(roman71.InvalidRomanNumeralError,
                              roman71.fromRoman, numeral.lower())

<span class="pykeyword">if</span> __name__ == <span class="pystring">"__main__"</span>:
    unittest.main()
</pre><div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td width="12" valign="top" align="left"><a href="http://it.diveintopython.net/unit_testing/handling_changing_requirements.html#roman.change.1.1"><img src="http://it.diveintopython.net/images/callouts/1.png" alt="1" border="0" width="12" height="12" /></a>
</td>
<td valign="top" align="left">
                        	I valori noti precedenti non cambiano (costituiscono sempre
                        	dei valori significativi da verificare), ma abbiamo bisogno
                        	di aggiungerne qualcun altro nella zona dei quattromila.
                        	Qui abbiamo incluso <tt class="literal">4000</tt> (il pi&ugrave; corto),
                        	<tt class="literal">4500</tt> (il secondo pi&ugrave; corto),
                        	<tt class="literal">4888</tt> (il pi&ugrave; lungo) e
                        	<tt class="literal">4999</tt> (il pi&ugrave; grande).
                        
                     </td>
</tr>
<tr>
<td width="12" valign="top" align="left"><a href="http://it.diveintopython.net/unit_testing/handling_changing_requirements.html#roman.change.1.2"><img src="http://it.diveintopython.net/images/callouts/2.png" alt="2" border="0" width="12" height="12" /></a>
</td>
<td valign="top" align="left">
                        	La definizione di &#8220;<span class="quote">input troppo grande</span>&#8221; &egrave;
                        	cambiata. Questo test chiamava la funzione <tt class="function">toRoman</tt>
                        	con il valore <tt class="literal">4000</tt> e si aspettava un
                        	errore; ora che i valori da <tt class="literal">4000</tt> a
                        	<tt class="literal">4999</tt> sono validi, dobbiamo innalzare
                        	il valore del test a <tt class="literal">5000</tt>.
                        
                     </td>
</tr>
<tr>
<td width="12" valign="top" align="left"><a href="http://it.diveintopython.net/unit_testing/handling_changing_requirements.html#roman.change.1.3"><img src="http://it.diveintopython.net/images/callouts/3.png" alt="3" border="0" width="12" height="12" /></a>
</td>
<td valign="top" align="left">
                        	La definizione di &#8220;<span class="quote">troppe cifre romane ripetute di
                           	seguito</span>&#8221; &egrave; anch'essa cambiata. Questo test chiamava
                        	<tt class="function">fromRoman</tt> con <tt class="literal">'MMMM'</tt> e si aspettava
                        	un errore; ora che <tt class="literal">'MMMM'</tt> &egrave; considerato
                        	un numero romano valido, dobbiamo portare il valore di
                        	test a <tt class="literal">'MMMM'</tt>.
                        
                     </td>
</tr>
<tr>
<td width="12" valign="top" align="left"><a href="http://it.diveintopython.net/unit_testing/handling_changing_requirements.html#roman.change.1.4"><img src="http://it.diveintopython.net/images/callouts/4.png" alt="4" border="0" width="12" height="12" /></a>
</td>
<td valign="top" align="left">
                        	Il test di consistenza ed il test sulle maiuscole/minuscole
                        	iterano su ogni numero nell'intervallo, da <tt class="constant">1</tt> a
                        	<tt class="literal">3999</tt>. Dato che l'intervallo si &egrave; espanso,
                        	questi cicli <tt class="literal">for</tt> hanno bisogno di essere aggiornati
                        	per arrivare fino a <tt class="literal">4999</tt>.
                        
                     </td>
</tr>
</table>
</div>
</div>
<p>
            	Ora i nostri test sono aggiornati in accordo con i nuovi
            	requisiti, ma non il nostro codice, per cui c'&egrave; da
            	aspettarsi che alcuni dei test falliscano.
            
         </p>
<div class="example"><a name="d0e24457"></a><h3 class="title">Esempio&nbsp;7.28.&nbsp;Output di <tt class="filename">romantest71.py</tt> a fronte di <tt class="filename">roman71.py</tt></h3><pre class="screen"><span class="computeroutput">
fromRoman should only accept uppercase input ... ERROR        </span><a name="roman.change.2.1"></a><img src="http://it.diveintopython.net/images/callouts/1.png" alt="1" border="0" width="12" height="12" /><span class="computeroutput">
toRoman should always return uppercase ... ERROR
fromRoman should fail with blank string ... ok
fromRoman should fail with malformed antecedents ... ok
fromRoman should fail with repeated pairs of numerals ... ok
fromRoman should fail with too many repeated numerals ... ok
fromRoman should give known result with known input ... ERROR </span><a name="roman.change.2.2"></a><img src="http://it.diveintopython.net/images/callouts/2.png" alt="2" border="0" width="12" height="12" /><span class="computeroutput">
toRoman should give known result with known input ... ERROR   </span><a name="roman.change.2.3"></a><img src="http://it.diveintopython.net/images/callouts/3.png" alt="3" border="0" width="12" height="12" /><span class="computeroutput">
fromRoman(toRoman(n))==n for all n ... ERROR                  </span><a name="roman.change.2.4"></a><img src="http://it.diveintopython.net/images/callouts/4.png" alt="4" border="0" width="12" height="12" /><span class="computeroutput">
toRoman should fail with non-integer input ... ok
toRoman should fail with negative input ... ok
toRoman should fail with large input ... ok
toRoman should fail with 0 input ... ok
</span></pre><div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td width="12" valign="top" align="left"><a href="http://it.diveintopython.net/unit_testing/handling_changing_requirements.html#roman.change.2.1"><img src="http://it.diveintopython.net/images/callouts/1.png" alt="1" border="0" width="12" height="12" /></a>
</td>
<td valign="top" align="left">
                        	Il nostro controllo sulle maiuscole/minuscole ora fallisce
                        	perch&eacute; si cicla da <tt class="constant">1</tt> a <tt class="literal">4999</tt>, ma la
                        	funzione <tt class="function">toRoman</tt> accetta solo numeri da <tt class="constant">1</tt> a
                        	<tt class="literal">3999</tt>, quindi va in errore non appena il
                        	test raggiunge <tt class="literal">4000</tt>.
                        
                     </td>
</tr>
<tr>
<td width="12" valign="top" align="left"><a href="http://it.diveintopython.net/unit_testing/handling_changing_requirements.html#roman.change.2.2"><img src="http://it.diveintopython.net/images/callouts/2.png" alt="2" border="0" width="12" height="12" /></a>
</td>
<td valign="top" align="left">
                        	Il test sui valori noti per <tt class="function">fromRoman</tt> fallisce anch'esso
                        	non appena si raggiunge <tt class="literal">'MMMM'</tt>, perch&eacute;
                        	<tt class="function">fromRoman</tt> lo considera ancora un numero romano non valido.
                        
                     </td>
</tr>
<tr>
<td width="12" valign="top" align="left"><a href="http://it.diveintopython.net/unit_testing/handling_changing_requirements.html#roman.change.2.3"><img src="http://it.diveintopython.net/images/callouts/3.png" alt="3" border="0" width="12" height="12" /></a>
</td>
<td valign="top" align="left">
                        	Il test  sui valori noti per <tt class="function">toRoman</tt> fallisce non appena
                        	si raggiunge <tt class="literal">4000</tt>, perch&eacute; <tt class="function">toRoman</tt> lo
                        	considera ancora fuori dall'intervallo dei valori validi.
                        
                     </td>
</tr>
<tr>
<td width="12" valign="top" align="left"><a href="http://it.diveintopython.net/unit_testing/handling_changing_requirements.html#roman.change.2.4"><img src="http://it.diveintopython.net/images/callouts/4.png" alt="4" border="0" width="12" height="12" /></a>
</td>
<td valign="top" align="left">
                        	Il test di consistenza fallisce anch'esso quando si arriva
                        	a <tt class="literal">4000</tt>, perch&eacute; <tt class="function">toRoman</tt> lo considera
                        	ancora fuori dall'intervallo.
                        
                     </td>
</tr>
</table>
</div><pre class="screen"><span class="computeroutput">
======================================================================
ERROR: fromRoman should only accept uppercase input
----------------------------------------------------------------------
</span><span class="traceback">Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage7\romantest71.py", line 161, in testFromRomanCase
    numeral = roman71.toRoman(integer)
  File "roman71.py", line 28, in toRoman
    raise OutOfRangeError, "number out of range (must be 1..3999)"
OutOfRangeError: number out of range (must be 1..3999)</span><span class="computeroutput">
======================================================================
ERROR: toRoman should always return uppercase
----------------------------------------------------------------------
</span><span class="traceback">Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage7\romantest71.py", line 155, in testToRomanCase
    numeral = roman71.toRoman(integer)
  File "roman71.py", line 28, in toRoman
    raise OutOfRangeError, "number out of range (must be 1..3999)"
OutOfRangeError: number out of range (must be 1..3999)</span><span class="computeroutput">
======================================================================
ERROR: fromRoman should give known result with known input
----------------------------------------------------------------------
</span><span class="traceback">Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage7\romantest71.py", line 102, in testFromRomanKnownValues
    result = roman71.fromRoman(numeral)
  File "roman71.py", line 47, in fromRoman
    raise InvalidRomanNumeralError, 'Invalid Roman numeral: %s' % s
InvalidRomanNumeralError: Invalid Roman numeral: MMMM</span><span class="computeroutput">
======================================================================
ERROR: toRoman should give known result with known input
----------------------------------------------------------------------
</span><span class="traceback">Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage7\romantest71.py", line 96, in testToRomanKnownValues
    result = roman71.toRoman(integer)
  File "roman71.py", line 28, in toRoman
    raise OutOfRangeError, "number out of range (must be 1..3999)"
OutOfRangeError: number out of range (must be 1..3999)</span><span class="computeroutput">
======================================================================
ERROR: fromRoman(toRoman(n))==n for all n
----------------------------------------------------------------------
</span><span class="traceback">Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage7\romantest71.py", line 147, in testSanity
    numeral = roman71.toRoman(integer)
  File "roman71.py", line 28, in toRoman
    raise OutOfRangeError, "number out of range (must be 1..3999)"
OutOfRangeError: number out of range (must be 1..3999)</span><span class="computeroutput">
----------------------------------------------------------------------
Ran 13 tests in 2.213s

FAILED (errors=5)</span></pre></div>
<p>
            	Ora che abbiamo dei test che falliscono perch&eacute; i nuovi
            	requisiti non sono ancora stati implementati, possiamo
            	cominciare a pensare di modificare il codice per
            	allinearlo ai nuovi test. (Una cosa a cui
            	occore un po' di tempo per abituarsi, quando si programma
            	usando i test delle unit&agrave; di codice, &egrave; il fatto che
            	il codice sotto verifica non
            	&egrave; mai pi&ugrave; &#8220;<span class="quote">avanti</span>&#8221; del codice di test. Di
            	solito rimane indietro e ci&ograve; significa che avete ancora
            	del lavoro da fare. Non appena si mette in pari, si
            	smette di programmare.)
            
         </p>
<div class="example"><a name="d0e24563"></a><h3 class="title">Esempio&nbsp;7.29.&nbsp;Trasformare in codice i nuovi requisiti (<tt class="filename">roman72.py</tt>)
            </h3><pre class="programlisting">
<span class="pystring">"""Convert to and from Roman numerals"""</span>
<span class="pykeyword">import</span> re

<span class="pycomment">#Define exceptions</span>
<span class="pykeyword">class</span><span class="pyclass"> RomanError</span>(Exception): <span class="pykeyword">pass</span>
<span class="pykeyword">class</span><span class="pyclass"> OutOfRangeError</span>(RomanError): <span class="pykeyword">pass</span>
<span class="pykeyword">class</span><span class="pyclass"> NotIntegerError</span>(RomanError): <span class="pykeyword">pass</span>
<span class="pykeyword">class</span><span class="pyclass"> InvalidRomanNumeralError</span>(RomanError): <span class="pykeyword">pass</span>

<span class="pycomment">#Define digit mapping</span>
romanNumeralMap = ((<span class="pystring">'M'</span>,  1000),
                   (<span class="pystring">'CM'</span>, 900),
                   (<span class="pystring">'D'</span>,  500),
                   (<span class="pystring">'CD'</span>, 400),
                   (<span class="pystring">'C'</span>,  100),
                   (<span class="pystring">'XC'</span>, 90),
                   (<span class="pystring">'L'</span>,  50),
                   (<span class="pystring">'XL'</span>, 40),
                   (<span class="pystring">'X'</span>,  10),
                   (<span class="pystring">'IX'</span>, 9),
                   (<span class="pystring">'V'</span>,  5),
                   (<span class="pystring">'IV'</span>, 4),
                   (<span class="pystring">'I'</span>,  1))

<span class="pykeyword">def</span><span class="pyclass"> toRoman</span>(n):
    <span class="pystring">"""convert integer to Roman numeral"""</span>
    <span class="pykeyword">if</span> <span class="pykeyword">not</span> (0 &lt; n &lt; 5000):                                                         <a name="roman.change.3.1"></a><img src="http://it.diveintopython.net/images/callouts/1.png" alt="1" border="0" width="12" height="12" />
        <span class="pykeyword">raise</span> OutOfRangeError, <span class="pystring">"number out of range (must be 1..4999)"</span>
    <span class="pykeyword">if</span> int(n) &lt;&gt; n:
        <span class="pykeyword">raise</span> NotIntegerError, <span class="pystring">"decimals can not be converted"</span>

    result = <span class="pystring">""</span>
    <span class="pykeyword">for</span> numeral, integer <span class="pykeyword">in</span> romanNumeralMap:
        <span class="pykeyword">while</span> n &gt;= integer:
            result += numeral
            n -= integer
    <span class="pykeyword">return</span> result

<span class="pycomment">#Define pattern to detect valid Roman numerals</span>
romanNumeralPattern = <span class="pystring">'^M?M?M?M?(CM|CD|D?C?C?C?)(XC|XL|L?X?X?X?)(IX|IV|V?I?I?I?)$'</span> <a name="roman.change.3.2"></a><img src="http://it.diveintopython.net/images/callouts/2.png" alt="2" border="0" width="12" height="12" />

<span class="pykeyword">def</span><span class="pyclass"> fromRoman</span>(s):
    <span class="pystring">"""convert Roman numeral to integer"""</span>
    <span class="pykeyword">if</span> <span class="pykeyword">not</span> s:
        <span class="pykeyword">raise</span> InvalidRomanNumeralError, <span class="pystring">'Input can not be blank'</span>
    <span class="pykeyword">if</span> <span class="pykeyword">not</span> re.search(romanNumeralPattern, s):
        <span class="pykeyword">raise</span> InvalidRomanNumeralError, <span class="pystring">'Invalid Roman numeral: %s'</span> % s

    result = 0
    index = 0
    <span class="pykeyword">for</span> numeral, integer <span class="pykeyword">in</span> romanNumeralMap:
        <span class="pykeyword">while</span> s[index:index+len(numeral)] == numeral:
            result += integer
            index += len(numeral)
    <span class="pykeyword">return</span> result
</pre></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td width="12" valign="top" align="left"><a href="http://it.diveintopython.net/unit_testing/handling_changing_requirements.html#roman.change.3.1"><img src="http://it.diveintopython.net/images/callouts/1.png" alt="1" border="0" width="12" height="12" /></a>
</td>
<td valign="top" align="left">
<tt class="function">toRoman</tt> ha solo bisogno di un piccolo cambio, nel controllo
                     	dell'intervallo. Dove prima controllavamo che
                     	<tt class="literal">0 &lt; n &lt; 4000</tt> ora controlliamo che
                     	<tt class="literal">0 &lt; n &lt; 5000</tt>. Inoltre cambiamo il
                     	messaggio di errore dell'eccezione sollevata per indicare il
                     	nuovo intervallo accettabile (<tt class="literal">1..4999</tt>
                     	invece di <tt class="literal">1..3999</tt>). Non abbiamo bisogno
                     	di fare alcun cambio per il resto della funzione; i nuovi casi
                     	vengono gi&agrave; gestiti correttamente. La funzione aggiunge
                     	tranquillamente una <tt class="literal">'M'</tt> per ogni migliaia;
                     	datole in input <tt class="literal">4000</tt>, tira fuori
                     	<tt class="literal">'MMMM'</tt>. L'unica ragione per cui prima non
                     	si comportava cos&igrave; era dovuta al fatto che veniva bloccata
                     	esplicitamente dal controllo di intervallo.
                     
                  </td>
</tr>
<tr>
<td width="12" valign="top" align="left"><a href="http://it.diveintopython.net/unit_testing/handling_changing_requirements.html#roman.change.3.2"><img src="http://it.diveintopython.net/images/callouts/2.png" alt="2" border="0" width="12" height="12" /></a>
</td>
<td valign="top" align="left">
                     	Non abbiamo bisogno di fare alcun cambio nella funzione
                     	<tt class="function">fromRoman</tt>. L'unica modifica riguarda la variabile
                     	<tt class="varname">romanNumeralPattern</tt>; se la osservate da
                     	vicino, vi accorgerete che abbiamo aggiunto un ulteriore
                     	<tt class="literal">M</tt> opzionale nella prima parte della
                     	espressione regolare. Questo consentir&agrave; fino a quattro
                     	caratteri <tt class="literal">M</tt> invece che fino a tre; di
                     	conseguenza verranno accettati i numeri romani fino
                     	all'equivalente di <tt class="literal">4999</tt> invece che solo
                     	fino all'equivalente di <tt class="literal">3999</tt>. La funzione
                     	<tt class="function">fromRoman</tt> in s&eacute; &egrave; assolutamente generica;
                             semplicemente, cerca cifre di numeri romani ripetute e ne
                             somma i 
                     	rispettivi valori senza preoccuparsi di quante volte essi
                     	si ripetano. L'unica ragione per cui la funzione non
                     	trattava correttamente <tt class="literal">'MMMM'</tt> in
                     	precedenza era perch&eacute; ne era esplicitamente impedita dal
                     	confronto con l'espressione regolare.
                     
                  </td>
</tr>
</table>
</div>
<p>
            	A questo punto potreste essere scettici sul fatto che due
                    piccole modifiche siano tutto ci&ograve; di cui abbiamo
                    bisogno. Ehi, non dovete fidarvi della mia parola. Osservate
                    da soli: 
            
         </p>
<div class="example"><a name="roman.roman72.output"></a><h3 class="title">Esempio&nbsp;7.30.&nbsp;Output di <tt class="filename">romantest72.py</tt> a fronte di <tt class="filename">roman72.py</tt></h3><pre class="screen"><span class="computeroutput">fromRoman should only accept uppercase input ... ok
toRoman should always return uppercase ... ok
fromRoman should fail with blank string ... ok
fromRoman should fail with malformed antecedents ... ok
fromRoman should fail with repeated pairs of numerals ... ok
fromRoman should fail with too many repeated numerals ... ok
fromRoman should give known result with known input ... ok
toRoman should give known result with known input ... ok
fromRoman(toRoman(n))==n for all n ... ok
toRoman should fail with non-integer input ... ok
toRoman should fail with negative input ... ok
toRoman should fail with large input ... ok
toRoman should fail with 0 input ... ok

----------------------------------------------------------------------
Ran 13 tests in 3.685s

OK</span> <a name="roman.change.4.1"></a><img src="http://it.diveintopython.net/images/callouts/1.png" alt="1" border="0" width="12" height="12" /></pre><div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td width="12" valign="top" align="left"><a href="http://it.diveintopython.net/unit_testing/handling_changing_requirements.html#roman.change.4.1"><img src="http://it.diveintopython.net/images/callouts/1.png" alt="1" border="0" width="12" height="12" /></a>
</td>
<td valign="top" align="left">
                        	Tutti i test hanno avuto successo. Smettete di scrivere codice.
                        
                     </td>
</tr>
</table>
</div>
</div>
<p>
            	Progettare test esaustivi significa non dover mai dipendere
            	da un programmatore che dice &#8220;<span class="quote">Fidati di me!</span>&#8221;.
            
         </p>
</div>
<table class="Footer" width="100%" border="0" cellpadding="0" cellspacing="0" summary="">
<tr>
<td width="35%" align="left"><br /><a class="NavigationArrow" href="http://it.diveintopython.net/unit_testing/handling_bugs.html">&lt;&lt;&nbsp;Come gestire gli errori di programmazione</a></td>
<td width="30%" align="center"><br />&nbsp;<span class="divider">|</span>&nbsp;<a href="http://it.diveintopython.net/unit_testing/index.html#roman.divein" title="7.1.&nbsp;Immergersi">1</a> <span class="divider">|</span> <a href="http://it.diveintopython.net/unit_testing/romantest.html" title="7.2.&nbsp;Introduzione al modulo romantest.py">2</a> <span class="divider">|</span> <a href="http://it.diveintopython.net/unit_testing/testing_for_success.html" title="7.3.&nbsp;Verificare i casi di successo">3</a> <span class="divider">|</span> <a href="http://it.diveintopython.net/unit_testing/testing_for_failure.html" title="7.4.&nbsp;Verificare i casi di errore">4</a> <span class="divider">|</span> <a href="http://it.diveintopython.net/unit_testing/testing_for_sanity.html" title="7.5.&nbsp;Verificare la consistenza">5</a> <span class="divider">|</span> <a href="http://it.diveintopython.net/unit_testing/stage_1.html" title="7.6.&nbsp;roman.py, fase 1">6</a> <span class="divider">|</span> <a href="http://it.diveintopython.net/unit_testing/stage_2.html" title="7.7.&nbsp;roman.py, fase 2">7</a> <span class="divider">|</span> <a href="http://it.diveintopython.net/unit_testing/stage_3.html" title="7.8.&nbsp;roman.py, fase 3">8</a> <span class="divider">|</span> <a href="http://it.diveintopython.net/unit_testing/stage_4.html" title="7.9.&nbsp;roman.py, fase 4">9</a> <span class="divider">|</span> <a href="http://it.diveintopython.net/unit_testing/stage_5.html" title="7.10.&nbsp;roman.py, fase 5">10</a> <span class="divider">|</span> <a href="http://it.diveintopython.net/unit_testing/handling_bugs.html" title="7.11.&nbsp;Come gestire gli errori di programmazione">11</a> <span class="divider">|</span> <span class="thispage">12</span> <span class="divider">|</span> <a href="http://it.diveintopython.net/unit_testing/refactoring.html" title="7.13.&nbsp;Rifattorizzazione">13</a> <span class="divider">|</span> <a href="http://it.diveintopython.net/unit_testing/postscript.html" title="7.14.&nbsp;Postscritto">14</a> <span class="divider">|</span> <a href="http://it.diveintopython.net/unit_testing/summary.html" title="7.15.&nbsp;Sommario">15</a>&nbsp;<span class="divider">|</span>&nbsp;
            </td>
<td width="35%" align="right"><br /><a class="NavigationArrow" href="http://it.diveintopython.net/unit_testing/refactoring.html">Rifattorizzazione&nbsp;&gt;&gt;</a></td>
</tr>
<tr>
<td colspan="3"><br /></td>
</tr>
</table>
<div class="Footer">
<p class="copyright">Copyright &copy; 2000, 2001, 2002, 2003 <a href="mailto:josh@servercobra.com">Mark Pilgrim</a></p>
<p class="copyright">Copyright &copy; 2003 Si veda l'appendice <span class="emphasis"><em>E: "Storia delle revisioni"</em></span></p>
</div>
</body>
</html>
